<?xml version="1.0" encoding="utf-8"?>
<post>
  <id>d126598f-09bb-4b0e-9972-f9c52074f5a2</id>
  <title>DevOps with Kubernetes and VSTS: Part 2</title>
  <slug>devops-with-kubernetes-and-vsts-part-2</slug>
  <shortUrl>http://bit.ly/2tkGdjg</shortUrl>
  <author></author>
  <pubDate>2017-07-04 04:34:06</pubDate>
  <lastModified>2019-05-01 10:19:30</lastModified>
  <content>&lt;p&gt;In &lt;a href="http://colinsalmcorner.com/post/devops-with-kubernetes-and-vsts-part-1" target="_blank"&gt;Part 1&lt;/a&gt; I looked at how to develop multi-container apps using &lt;a href="https://kubernetes.io/" target="_blank"&gt;Kubernetes&lt;/a&gt; (k8s) - and more specifically, &lt;a href="https://github.com/kubernetes/minikube" target="_blank"&gt;minikube&lt;/a&gt;, which is a full k8s environment that runs a single node on a VM on your laptop. In that post I walk through cloning &lt;a href="https://github.com/colindembovsky/AzureAureliaDemo" target="_blank"&gt;this repo&lt;/a&gt; (be sure to look at the docker branch) which contains two containers: a DotNet Core API container and a frontend SPA (&lt;a href="http://aurelia.io/" target="_blank"&gt;Aurelia&lt;/a&gt;) container (also hosted as static files in a DotNet Core app). I show how to build the containers locally and get them running in minikube, taking advantage of ConfigMaps to handle configuration.&lt;/p&gt;&lt;p&gt;In this post, I will show you how to take the local development into CI/CD and walk through creating an automated build/release pipeline using VSTS. We'll create an Azure Container Registry and Azure Container Services using k8s as the orchestration mechanism.&lt;/p&gt;&lt;p&gt;I do recommend watching &lt;a href="https://twitter.com/nigelpoulton" target="_blank"&gt;Nigel Poulton&lt;/a&gt;'s excellent &lt;a href="https://www.pluralsight.com/courses/getting-started-kubernetes" target="_blank"&gt;Getting Started with Kubernetes&lt;/a&gt; PluralSight course and reading &lt;a href="https://blogs.msdn.microsoft.com/devops/2017/06/09/deploying-applications-to-azure-container-service/" target="_blank"&gt;this post&lt;/a&gt; by Atul Malaviya from Microsoft. Nigel's course was an excellent primer into Kubernetes and Atul's post was helpful to see how VSTS and k8s interact - but neither course nor post quite covered a whole &lt;em&gt;pipeline&lt;/em&gt;. How do you update your images in a CI/CD pipeline was a question not answered to my satisfaction. So after some experimentation, I am writing this post!&lt;/p&gt;&lt;h2&gt;Creating a k8s Environment using Azure Container Services&lt;/h2&gt;&lt;p&gt;You can run k8s on-premises, or in AWS or Google Cloud. However, I think Azure Container Services makes spinning up an k8s cluster really straightforward. However, the pipeline I walk through in this post is cloud-host agnostic - it will work against any k8s cluster. We'll also set up a private Container Registry in Azure, though once again, you can use any container registry you choose.&lt;/p&gt;&lt;p&gt;To spin up a k8s cluster you can use the portal, but the &lt;a href="https://docs.microsoft.com/en-us/cli/azure/overview" target="_blank"&gt;Azure CLI&lt;/a&gt; makes it a snap and you get to save the keys you'll need to connect, so I'll use that mechanism. I'll also use Bash for Windows with kubectl, but any platform running kubectl and the Azure CLI will do.&lt;/p&gt;&lt;p&gt;Here are the commands:&lt;/p&gt;&lt;pre class="brush: bash"&gt;# set some variables
export RG="cd-k8s"
export clusterName="cdk8s"
export location="westus"
# create a folder for the cluster ssh-keys
mkdir cdk8s

# login and create a resource group
az login
az group create --location $location --name $RG

# create an ACS k8s cluster
az acs create --orchestrator-type=kubernetes --resource-group $RG --name=$ClusterName --dns-prefix=$ClusterName --generate-ssh-keys --ssh-key-value ~/cdk8s/id_rsa.pub --location $location --agent-vm-size Standard_DS1_v2 --agent-count 2

# create an Azure Container Registry
az acr create --resource-group $RG --name $ClusterName --location $location --sku Basic --admin-enabled

# configure kubectl
az acs kubernetes get-credentials --name $ClusterName --resource-group $RG --file ~/cdk8s/kubeconfig --ssh-key-file ~/cdk8s/id_rsa
export KUBECONFIG="~/cdk8s/kubeconfig"

# test connection
kubectl get nodes
NAME                    STATUS                     AGE       VERSION
k8s-agent-96607ff6-0    Ready                      17m       v1.6.6
k8s-agent-96607ff6-1    Ready                      17m       v1.6.6
k8s-master-96607ff6-0   Ready,SchedulingDisabled   17m       v1.6.6&lt;/pre&gt;&lt;p&gt;Notes:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Lines 2-4: create some variables&lt;/li&gt;&lt;li&gt;Line 6: create a folder for the ssh-keys and kubeconfig&lt;/li&gt;&lt;li&gt;Line 9: login to Azure (this prompts you to open a browser with the device login - if you don't have an Azure subscription create a free one now!)&lt;/li&gt;&lt;li&gt;Line 10: create a resource group to house all the resources we're going to create&lt;/li&gt;&lt;li&gt;Line 13: create a k8s cluster using the resource group we just created and the name we pass in; generate ssh-keys and place them in the specified folder; we want 2 agents (nodes) with the specified VM size&lt;/li&gt;&lt;li&gt;Line 16: create an Azure Container registry in the same resource group with admin access enabled&lt;/li&gt;&lt;li&gt;Line 19: get the credentials necessary to connect to the cluster using kubectl; use the supplied ssh-key and save the creds to the specified kubeconfig file&lt;/li&gt;&lt;li&gt;Line 20: tell kubectl to use this config rather than the default config (which may have other k8s clusters or minikube config)&lt;/li&gt;&lt;li&gt;Line 23: test that we can connect to the cluster&lt;/li&gt;&lt;li&gt;Lines 24-27: we are indeed connecting successfully!&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;If you open a browser and navigate to the Azure portal and then open your resource group, you'll see how much stuff got created by the few preceding simple commands:&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/6bad8157-6f0f-4769-ad87-dba0559fd431.png" target="_blank"&gt;&lt;img width="294" height="172" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/c6e7cdb2-8377-476e-b9cf-581ff29b0ddf.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Don't worry - you'll not need to manage these resources yourself. Azure and the k8s cluster manage them for you!&lt;/p&gt;&lt;h2&gt;Namespaces&lt;/h2&gt;&lt;p&gt;Before we actually create the build and release for our container apps, let's consider the promotion model. Typically there's Dev-&amp;gt;UAT-&amp;gt;Prod or something similar. In the case of k8s, minikube is the local dev environment - and that's great since this is a full k8s cluster on your laptop - so you get to run your code locally including using k8s "meta-constructs" such as configMaps. So what about UAT and Prod? You could spin up separate clusters, but that could end up being expensive. You can also share the prod cluster resources by leveraging &lt;em&gt;namespaces&lt;/em&gt;. Namespaces in k8s can be security boundaries, but they can also be isolation boundaries. I can deploy new versions of my app to a dev namespace - and even though that namespace shares the resources of the prod namespace, it's completely invisible, including its own IPs etc. Of course I shouldn't load test in this configuration since loading the dev namespace is going to potentially steal resources from prod apps. This is conceptually similar to deployment slots in Azure App Services - they can be used to test apps lightly before promoting to prod.&lt;/p&gt;&lt;p&gt;When you spin up a k8s cluster, besides kube-system and kube-public namespaces (which house the k8s pods) there is a "default" namespace. If you don't specify otherwise, any services, deploymens or pods you create will go to this namespace. However, let's create two additional namespaces: dev and prod. Here's the yml:&lt;/p&gt;&lt;pre class="brush: plain"&gt;apiVersion: v1
kind: Namespace
metadata:
  name: dev
---
apiVersion: v1
kind: Namespace
metadata:
  name: prod&lt;/pre&gt;&lt;p&gt;This file contains the definitions for both namespaces. Run the apply command to create the namespaces. Once completed, you can list all the namespaces in the cluster:&lt;/p&gt;&lt;pre class="brush: bash; highlight:[1,5]"&gt;kubectl apply -f namespaces.yml
namespace "dev" created
namespace "prod" created

kubectl get namespaces
NAME          STATUS    AGE
default       Active    27m
dev           Active    20s
kube-public   Active    27m
kube-system   Active    27m
prod          Active    20s&lt;/pre&gt;&lt;h2&gt;Configuring the Container Registry Secret&lt;/h2&gt;&lt;p&gt;One more piece of setup before we get to the code: when the k8s cluster is pulling images to run, we're going to want it to pull from the Container Registry we just created. Access to this registry is secured since this is a private registry. So we need to configure a registry secret that we can just reference in our deployment yml files. Here are the commands:&lt;/p&gt;&lt;pre class="brush: bash; highlight: [1,6]"&gt;az acr credential show --name $ClusterName --output table
USERNAME    PASSWORD                          PASSWORD2
----------  --------------------------------  --------------------------------
cdk8s       some-long-key-1                   some-long-key-2

kubectl create secret docker-registry regsecret --docker-server=$ClusterName.azurecr.io --docker-username=$ClusterName --docker-password=&amp;lt;some-long-key-1&amp;gt; --docker-email=admin@azurecr.io
secret "regsecret" created&lt;/pre&gt;&lt;p&gt;The first command uses az to get the keys for the admin user (the admin username is the same as the name of the Container registry: so I created cdk8s.azurecr.io and so the admin username is cdk8s). Pass in one of the keys (it doesn't really matter which one) as the password. The email address is not used, so this can be anything. We now have a registry secret called "regsecret" that we can refer to when deploying to the k8s cluster. K8s will use this secret to authenticate to the registry.&lt;/p&gt;&lt;h2&gt;Configure VSTS Endpoints&lt;/h2&gt;&lt;p&gt;We now have the k8s cluster and container registry configured. Let's add these endpoints to VSTS so that we can push containers to the registry during a build and perform commands against the k8s cluster during a release. The endpoints allow us to abstract away authentication so that we don't need to store credentials in our release definitions directly. You can also restrict who can view/consume the endpoints using endpoint roles.&lt;/p&gt;&lt;p&gt;Open VSTS and navigate to a Team Project (or just create a new one). Go to the team project and click the gear icon to navigate to the settings hub for that Team Project. Then click Services. Click "+ New Services" and create a new Docker Registry endpoint. Use the same credentials you used to create the registry secret in k8s using kubectl:&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/b5f00719-4e56-4306-ba72-100952c2c478.png" target="_blank"&gt;&lt;img width="297" height="206" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/a7511c54-2694-49d4-b38f-f0a71871ff39.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Next create a k8s endpoint. For the url, it will be https://$ClusterName.$location.cloudapp.azure.com (where clustername and location are the variables we used earlier to create the cluster). You'll need to copy the entire contents of the ~/cdk8s/kubeconfig file (or whatever you called it) that was output when you ran the az acs kubernetes get-credential command into the credentials textbox:&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/f34492c8-3acb-4069-af9c-5732a04293d5.png" target="_blank"&gt;&lt;img width="301" height="201" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/4b2980ec-f363-45a0-8146-a9d4f735ddb4.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We now have two endpoints that we can use in the build/release definitions:&lt;/p&gt;&lt;p align="center"&gt;&lt;a href="http://colinsalmcorner.com/posts/files/6672b99f-4f86-460e-9ed9-1ed5052a1125.png" target="_blank"&gt;&lt;img width="327" height="156" title="image" style="display: inline; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/f0a853d8-05dc-4a74-83f4-5a4a21a17264.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;The Build&lt;/h2&gt;&lt;p&gt;We can now create a build that compiles/tests our code, creates docker images and pushes the images to the Container Registry, tagging them appropriately. Click on Build &amp;amp; Release and then click on Builds to open the build hub. Create a new build definition. Select the ASP.NET Core template and click apply. Here are the settings we'll need:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Tasks-&amp;gt;Process: Set the name to something like k8s-demo-CI and select the "Hosted Linux Preview" queue&lt;/li&gt;&lt;li&gt;Options: change the build number format to "1.0.0$(rev:.r)" so that the builds have a 1.0.0.x format&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;Get Sources: Select the Github repo, authorizing via OAuth or PAT. Select the AzureAureliaDemo and set the default branch to docker. You may have to fork the repo (or just import it into VSTS) if you're following along.&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;DotNet Restore - leave as-is&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;DotNet Build - add "--version-suffix $(Build.BuildNumber)" to the build arguments to match the assembly version to the build number&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;DotNet Test - disable this task since there are no DotNet tests in this solution (you can of course re-enable this task when you have tests)&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;Add an "npm" task. Set the working folder to "frontend" and make sure the command is "install"&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;Add a "Command line" task. Set the tool to "node", the arguments to "node_modules/aurelia-cli/bin/aurelia-cli.js test" and the working folder to "frontend". This will run Aurelia tests.&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;Add a "Publish test results" task. Set "Test Results files" to "test*.xml" and "Search Folder" to "$(Build.SourcesDirectory)/frontend/testresults". This publishes the Aurelia test results.&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;Add a "Publish code coverage" task. Set "Coverage Tool" to "Cobertura", "Summary File" to "$(Build.SourcesDirectory)/frontend/reports/coverage/cobertura.xml" and "Report Directory" to "$(Build.SourcesDirectory)/frontend/reports/coverage/html". This publishes the Aurelia test coverage results.&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;Add a "Command line" task. Set the tool to "node", the arguments to "node_modules/aurelia-cli/bin/aurelia-cli.js build --env prod" and the working folder to "frontend". This transpiles, processes and packs the Aurelia SPA app.&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;DotNet Publish. Change the Arguments to "-c $(BuildConfiguration) -o publish" and uncheck "Zip Published Projects"&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;Add a "Docker Compose" task. Set the "Container Registry Type" to "Azure Container Registry" and set your Azure subscription and container registry to the registry we created an endpoint for earlier. Set "Additional Docker Compose Files" to "docker-compose.vsts.yml", the action to "Build service images" and "Additional Image Tags" to "$(Build.BuildNumber)" so that the build number is used as the tag for the images.&lt;/li&gt;&lt;li&gt;Clone the "Docker Compose" task. Rename it to "Push service images" and change the action to "Push service images". Check the "Include Latest Tag" checkbox.&lt;/li&gt;&lt;li&gt;Tasks-&amp;gt;Publish Artifact. Set both "Path to Publish" and "Artifact Name" to k8s. This publishes the k8s yml files so that they are available in the release.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The final list of tasks looks something like this:&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/b87cebd8-96ec-441d-9982-fbf88fa41643.png" target="_blank"&gt;&lt;img width="218" height="282" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/3fd6a327-e654-4f27-8a96-85018b35995a.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;You can now Save and Queue the build. When the build is complete, you'll see the test/coverage information in the summary.&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/a89cefb0-072e-4e9b-bc64-71db8a8c1f99.png" target="_blank"&gt;&lt;img width="313" height="156" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/eb80b904-b95d-418a-8fd9-c6ba74a1e81d.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;You can also take a look at your container registry to see the newly pushed service images, tagged with the build number.&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/0616d7c0-9c85-427b-a667-1fd8e1d69ee8.png" target="_blank"&gt;&lt;img width="315" height="200" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/df2dc709-8e56-4590-bde2-a3a801c785d9.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;The Release&lt;/h2&gt;&lt;p&gt;We can now configure a release that will create/update the services we need. For that we're going to need to manage configuration. Now we could just hard-code the configuration, but that could mean sensitive data (like passwords) would end up in source control. I prefer to tokenize any configuration and have Release Management keep the sensitive data outside of source control. VSTS Release Management allows you to create secrets for individual environments or releases or you can create them in reusable Variable Groups. You can also now easily &lt;a href="https://www.visualstudio.com/en-us/docs/build/concepts/library/variable-groups#link-secrets-from-an-azure-key-vault-as-variables" target="_blank"&gt;integrate with Azure Key Vault&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;To replace the tokens with environment-specific values, we're going to need a task that can do token substitution. Fortunately, I've got a (cross-platform) ReplaceTokens task in &lt;a href="http://bit.ly/cacbuildtasks" target="_blank"&gt;Colin's ALM Corner Build &amp;amp; Release Tasks&lt;/a&gt; extension on the VSTS Marketplace. Click on the link to navigate to the page and click install to install the extension onto your account.&lt;/p&gt;&lt;p&gt;From the build summary page, scroll down on the right hand side to the "Deployments" section and click the "Create release" link. You can also click on Releases and create a new definition from there. Start from an Empty template and select your team project and the build that you just completed as the source build. Check the "Continuous Deployment" checkbox to automatically trigger a release for every good build.&lt;/p&gt;
&lt;p&gt;Rename the definition to "k8s" or something descriptive. On the "General" tab change the release number format to "$(Build.BuildNumber)-$(rev:r)" so that you can easily see the build number in the name of the release. Back on Environments, rename Environment 1 to "dev". Click on the "Run on Agent" link and make sure the Deployment queue is "Hosted Linux Preview". Add the following tasks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Replace Tokens&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Source Path: browse to the k8s folder&lt;/li&gt;&lt;li&gt;Target File Pattern: "*-release.yml". This performs token replacement on any yml file with a name that ends in "-release." There's 3: back- and frontend service/deployment files and the frontend config file. This task finds the tokens in the file (with pre- and postfix __) and looks for variables with the same name. Each variable is replaced with its corresponding value. We'll create the variables shortly.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Kubernetes Task 1 (apply frontend config)&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Set the k8s connection to the endpoint you created earlier. Also set the connection details for the Azure Container Registry. This applies to all the Kubernetes tasks. Set the Command to "apply", check the "Use Configuration Files" option and set the file to the k8s/app-demo-frontend-config-release.yml file using the file picker. Add "--namespace $(namespace)" to the arguments textbox.&lt;/li&gt;&lt;li&gt;&lt;a href="http://colinsalmcorner.com/posts/files/559e2dc0-4108-44fd-a864-5fc66e23206b.png" target="_blank"&gt;&lt;img width="244" height="220" title="image" style="display: inline; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/d6391629-5031-4dfa-b749-b8f276bbf890.png" border="0"&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Kubernetes Task 2 (apply backend service/deployment definition)&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Set the same connection details for the k8s service and Azure Container Registry. This time, set "Secret Name" to "regsecret" (this is the name of the secret we created when setting up the k8s cluster, and is also the name we refer to for the imagePullSecret in the Deployment definitions). Check the "Force update secret" setting. This ensures that the secret value in k8s matches the key from Azure. You could also skip this option since we created the key manually.&lt;/li&gt;&lt;li&gt;Set the Command to "apply", check the "Use Configuration Files" option and set the file to the k8s/app-demo-backend-release.yml file using the file picker. Add "--namespace $(namespace)" to the arguments textbox.&lt;/li&gt;&lt;li&gt;&lt;a href="http://colinsalmcorner.com/posts/files/e7c5135d-5e5e-428f-8242-23bec4121a36.png" target="_blank"&gt;&lt;img width="244" height="220" title="image" style="display: inline; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/45cf619c-0939-4999-9169-220e6c2b18d4.png" border="0"&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Kubernetes Task 3 (apply frontend service/deployment definition)&lt;/li&gt;&lt;ul&gt;&lt;li&gt;This is the same as the previous task except that the filename is k8s/app-demo-frontend-release.yml.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Kubernetes Task 4 (update backend image)&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Set the same connection details for the k8s service and Azure Container Registry. No secret required here. Set the Command to "set" and specify Arguments as "image deployment/demo-backend-deployment backend=$(ContainerRegistry)/api:$(Build.BuildNumber) --record --namespace=$(namespace)".&lt;/li&gt;&lt;li&gt;This updates the version (tag) of the container image to use. K8s will do a rolling update that brings new containers online and takes the old containers offline in such a manner that the service is still up throughout the bleed over.&lt;/li&gt;&lt;li&gt;&lt;a href="http://colinsalmcorner.com/posts/files/48c2502e-771c-4b66-a09b-e897957ae39d.png" target="_blank"&gt;&lt;img width="244" height="224" title="image" style="display: inline; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/eb169cb5-c6b0-4f08-9573-8a154442eda0.png" border="0"&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Kubernetes Task 5 (update the frontend image)&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Same as the previous task except the Arguments are "image deployment/demo-frontend-deployment frontend=$(ContainerRegistry)/frontend:$(Build.BuildNumber) --record --namespace=$(namespace)"&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Click on the "…" button on the "dev" card and click Configure Variables. Set the following values:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;BackendServicePort: 30081&lt;/li&gt;&lt;li&gt;FrontendServicePort: 30080&lt;/li&gt;&lt;li&gt;ContainerRegistry: &amp;lt;your container reg&amp;gt;.azurecr.io&lt;/li&gt;&lt;li&gt;namespace: $(Release.EnvironmentName)&lt;/li&gt;&lt;li&gt;AspNetCoreEnvironment: development&lt;/li&gt;&lt;li&gt;baseUri: http://$(BackendServiceIP)/api&lt;/li&gt;&lt;li&gt;BackendServiceIP: 10.0.0.1&lt;/li&gt;&lt;li&gt;&lt;a href="http://colinsalmcorner.com/posts/files/f3bcd024-b1bc-4850-bd39-d6a0fd066361.png" target="_blank"&gt;&lt;img width="244" height="145" title="image" style="display: inline; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/5e2102f5-fb21-4442-a70a-d4f793a2f48b.png" border="0"&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/ul&gt;
&lt;p&gt;This sets environment-specific values for all the variables in the yml files. The Replace Tokens task takes care of injecting into the files for us. Let's take a quick look at one of the tokenized files (tokenized lines are highlighted):&lt;/p&gt;
&lt;pre class="brush: plain; highlight: [14,31,36]"&gt;apiVersion: v1
kind: Service
metadata:
  name: demo-frontend-service
  labels:
    app: demo
spec:
  selector:
    app: demo
    tier: frontend
  ports:
    - protocol: TCP
      port: 80
      nodePort: __FrontendServicePort__
  type: LoadBalancer
---
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: demo-frontend-deployment
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: demo
        tier: frontend
    spec:
      containers:
        - name: frontend
          image: __ContainerRegistry__/frontend
          ports:
          - containerPort: 80
          env:
          - name: "ASPNETCORE_ENVIRONMENT"
            value: "__AspNetCoreEnvironment__"
          volumeMounts:
            - name: config-volume
              mountPath: /app/wwwroot/config/
          imagePullPolicy: Always
      volumes:
        - name: config-volume
          configMap:
            name: demo-app-frontend-config
      imagePullSecrets:
        - name: regsecret&lt;/pre&gt;&lt;p&gt;A note on the value for BackendServiceIP: we use 10.0.0.1 as a temporary placeholder, since Azure will create an IP for this service when k8s spins up the backend service (you'll see a public IP address in the resource group in the Azure portal). We will have to run this once to create the services and then update this to the real IP address so that the frontend service works correctly. We also use $(Release.EnvironmentName) as the value for namespace - so "dev" (and later "prod") need to match the namespaces we created, including casing.&lt;/p&gt;&lt;p&gt;If the service/deployment and config don't change, then the first 3 k8s tasks are essentially no-ops. Only the "set" commands are actually going to do anything. But this is great - since the service/deployment and config files can be applied idempotently! They change when they have to and don't mess anything up when they don't change - perfect for repeatable releases!&lt;/p&gt;&lt;p&gt;Save the definition. Click "+ Release" to create a new release. Click on the release number (it will be something like 1.0.0.1-1) to open the release. Click on logs to see the logs.&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/085adf52-57c4-4402-ac69-73568d4d69d3.png" target="_blank"&gt;&lt;img width="286" height="147" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/b60dce3f-cb90-4fda-8b40-0878e1cddb2b.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Once the release has completed, you can see the deployment in the Kubernetes dashboard. To open the dashboard, execute the following command:&lt;/p&gt;&lt;pre class="brush: bash; highlight:[1]"&gt;az acs kubernetes browse -n $ClusterName -g $RG --ssh-key-file ~/cdk8s/id_rsa

Proxy running on 127.0.0.1:8001/ui
Press CTRL+C to close the tunnel...
Starting to serve on 127.0.0.1:8001&lt;/pre&gt;&lt;p&gt;The last argument is the path to the SSH key file that got generated when we created the cluster - adjust your path accordingly. You can now open a browser to &lt;a href="http://localhost:8001/ui"&gt;http://localhost:8001/ui&lt;/a&gt;. Change the namespace dropdown to "dev" and click on Deployments. You should see 2 successful deployments - each showing 2 healthy pods. You can also see the images that are running in the deployments - note the build number as the tag! &lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/5b95aaac-6630-484d-839d-91f72a5ac868.png" target="_blank"&gt;&lt;img width="289" height="93" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/2dc79a1f-343b-4604-a6e3-48d2101ac5d2.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;To see the services, click on Services.&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/8c6ad693-0c98-4913-84a2-943de4f9666c.png" target="_blank"&gt;&lt;img width="283" height="135" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/6af595c5-dba2-4307-b362-9a1ad17593e7.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Now we have the IP address of the backend service, so we can update the variable in the release. We can then queue a new release - this time, the frontend configuration is updated with the correct IP address for the backend service (in this case 23.99.58.48). We can then browse to the frontend service IP address and see our service is now running!&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/251a6544-7bf1-4a88-9ea2-c60ba870e832.png" target="_blank"&gt;&lt;img width="234" height="244" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/201d8dd0-1864-456e-8579-502f9fbe8c44.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Creating Prod&lt;/h3&gt;&lt;p&gt;Now that we are sure that the dev environment is working, we can go back to the release and clone "dev" to "prod". Make sure you specify a post-approval on dev (or a pre-approval on prod) so that there's a checkpoint between the two environments.&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/a0f5d264-eca5-4357-a140-82df86770e6f.png" target="_blank"&gt;&lt;img width="288" height="177" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/e0f19be7-9584-4995-8438-d98e50172b76.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We can then just change the node ports, AspNetCoreEnvironment and BackendServiceIP variables and we're good to go! Of course we need to deploy once to the prod namespace before we see the k8s/Azure assigned IP address for the prod backend and then re-run the release to update the config.&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/b5073661-75db-4c19-8c48-079a1310e1a0.png" target="_blank"&gt;&lt;img width="274" height="163" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/90eeb703-a23f-472a-99f1-c38fa433e989.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We could also remove the nodePort from the definitions altogether and let k8s decide on a node port - but if it's explicit then we know what port the service is going to run on within the cluster (not externally).&lt;/p&gt;&lt;p&gt;I did get irritated having to specify "--namespace" for each command - so irritated, in fact, that I've created a &lt;a href="https://github.com/Microsoft/vsts-tasks/pull/4657" target="_blank"&gt;Pull Request&lt;/a&gt; in the vsts-tasks Github repo to expose namespace as an optional UI element!&lt;/p&gt;&lt;h2&gt;End to End&lt;/h2&gt;&lt;p&gt;Now that we have the dev and prod environments set up in a CI/CD pipeline, we can make a change to the code. I'll change the text below the version to "K8s demo" and commit the change. This triggers the build, creating a newer container image and running tests, which in turn triggers the release to dev. Now I can see the change in dev (which is on 1.0.0.3 or some newer version than 1.0.0.1), while prod is still on version 1.0.0.1.&lt;/p&gt;&lt;p&gt;&lt;a href="http://colinsalmcorner.com/posts/files/08b983cf-05d9-40fc-aadb-b0b6ceb823cb.png"&gt;&lt;img width="311" height="156" title="image" style="margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="image" src="http://colinsalmcorner.com/posts/files/ab172b16-ae83-44f1-825c-e901a4fa9438.png" border="0"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Approve dev in Release Management and prod kicks off - and a few seconds later prod is now also on 1.0.0.3.&lt;/p&gt;&lt;p&gt;I've exported the json definitions for both the build and the release into &lt;a href="https://github.com/colindembovsky/AzureAureliaDemo/tree/docker/vsts-json" target="_blank"&gt;this folder&lt;/a&gt; - you can attempt to import them (I'm not sure if that will work) but you can refer to them in any case.&lt;/p&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;k8s shows great promise as a solid container orchestration mechanism. The yml infrastructure-as-code is great to work with and easy to version control. The deployment mechanism means you can have very minimal (if any) downtime when deploying and having access to configMaps and secrets makes the entire process secure. Using the Azure CLI you can create a k8s cluster and Azure Container registry with a couple simple commands. The VSTS integration through the k8s tasks makes setting up CI/CD relatively easy - all in all it's a great development workflow. Throw in minikube as I described in &lt;a href="http://colinsalmcorner.com/post/devops-with-kubernetes-and-vsts-part-1" target="_blank"&gt;Part 1&lt;/a&gt; of this series, which gives you a full k8s cluster for local development on your laptop, and you have a great dev/CI/CD workflow.&lt;/p&gt;&lt;p&gt;Of course a CI/CD pipeline doesn't battle test the actual applications in production! I would love to hear your experiences running k8s &lt;em&gt;in production&lt;/em&gt; - sound out in the comments if you have some experience of running apps in a k8s cluster in prod!&lt;/p&gt;&lt;p&gt;Happy k8sing! &lt;/p&gt;</content>
  <ispublished>true</ispublished>
  <categories>
    <category>docker</category>
    <category>DevOps</category>
  </categories>
  <comments>
    <comment isAdmin="false" isApproved="true" id="043e7be1-80e5-4033-84f5-3f87d72be0cd">
      <author>Natalia</author>
      <email>efimtceva@gmail.com</email>
      <website></website>
      <ip>91.77.64.201</ip>
      <userAgent>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299</userAgent>
      <date>2018-01-12 07:59:06</date>
      <content>Colin , &lt;br /&gt;Thank you a lot for these articles. Really useful!</content>
    </comment>
    <comment isAdmin="true" isApproved="true" id="c3a6cea3-a007-4d23-8a94-8ad5449841b0">
      <author>Colin Dembovsky</author>
      <email>colindembovsky@gmail.com</email>
      <website>http://colinsalmcorner.com/</website>
      <ip>50.35.94.220</ip>
      <userAgent>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.168 Safari/537.36</userAgent>
      <date>2018-02-15 04:14:55</date>
      <content>Hi @Natalia&lt;br /&gt;&lt;br /&gt;Thanks for giving me some positive feedback - really happy to help!</content>
    </comment>
    <comment isAdmin="false" isApproved="true" id="b4f24332-724e-4a09-9d95-5067c19fd2fe">
      <author>Wennder dos Santos</author>
      <email>wennder.santos@outlook.com</email>
      <website>http://wenndersantos.net/</website>
      <ip>186.204.187.45</ip>
      <userAgent>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36</userAgent>
      <date>2018-04-11 05:2:08</date>
      <content>Colin,&lt;br /&gt;&lt;br /&gt;this is the best post about k8s on azure! even better than the docs :)&lt;br /&gt;&lt;br /&gt;Just one thing in the commands, you created the variable clusterName but in the commands, you are using a variable ClusterName.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Thanks!</content>
    </comment>
    <comment isAdmin="true" isApproved="true" id="8ca2d9a9-d623-4d76-94cf-b637c37656ca">
      <author>Colin Dembovsky</author>
      <email>colindembovsky@gmail.com</email>
      <website>http://colinsalmcorner.com/</website>
      <ip>73.92.222.71</ip>
      <userAgent>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</userAgent>
      <date>2018-07-03 14:47:07</date>
      <content>Thanks @Wennder - some commmands are case sensitive and some aren&amp;#39;t, so I haven&amp;#39;t noticed an error in this case. Good catch!</content>
    </comment>
    <comment isAdmin="false" isApproved="false" id="0fe5d17b-5344-4655-aeca-d490d034a24a">
      <author>steven leonard</author>
      <email>sleonard84@msn.com</email>
      <website></website>
      <ip>86.154.171.238</ip>
      <userAgent>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36</userAgent>
      <date>2018-08-16 06:39:18</date>
      <content>This was useful, thanks colin</content>
    </comment>
    <comment isAdmin="false" isApproved="false" id="efc010f3-0fd9-42b4-9ef4-93d9c9ad434c">
      <author>rajani</author>
      <email>rajani3652@gmail.com</email>
      <website>https://devopsonlinehub.com/</website>
      <ip>49.206.196.217</ip>
      <userAgent>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36</userAgent>
      <date>2019-05-01 10:19:30</date>
      <content>Excellent list..can give a lot of insights on elearning industry, Thankyou</content>
    </comment>
  </comments>
  <viewCount>0</viewCount>
</post>