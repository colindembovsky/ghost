<?xml version="1.0" encoding="utf-8"?>
<post>
  <id>cbf59201-80f9-47b5-934e-7d65c6fafa8d</id>
  <title>Using the TFS API to display results of a Hierarchical Work Item Query</title>
  <slug>using-the-tfs-api-to-display-results-of-a-hierarchical-work-item-query</slug>
  <shortUrl>http://bit.ly/1koqgMV</shortUrl>
  <author>Colin Dembovsky</author>
  <pubDate>2011-10-10 11:37:00</pubDate>
  <lastModified>2020-04-07 05:06:16</lastModified>
  <content>&lt;h2&gt;RunQuery won’t work for Hierarchical Queries&lt;/h2&gt; &lt;p&gt;Using the TFS API to display results of a flat query is fairly straightforward – once you have the &lt;a href="http://msdn.microsoft.com/en-us/library/bb130306.aspx" target="_blank"&gt;WIQL&lt;/a&gt; you just execute the &lt;a href="http://msdn.microsoft.com/en-us/library/microsoft.teamfoundation.workitemtracking.client.query.runquery.aspx" target="_blank"&gt;RunQuery()&lt;/a&gt; method and voila – a nice WorkItemCollection for you to enumerate over. However, if you try to execute RunQuery() on a tree or one-hop WIQL, you’ll see this error message:&lt;/p&gt;&lt;pre&gt;TF248021: You have specified a query string that is not valid when you use the query method for a flat list of work items. You cannot specify a parameterized query or a query string for linked work items with the query method you specified.&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;I was working on a proof-of-concept and needed to display the result of a Work Item Query in a WPF form. Once I saw the TF248012 error, I &lt;strike&gt;googled&lt;/strike&gt; binged a bit to see if I could work out how to run a hierarchical query. That brought me to the &lt;a href="http://msdn.microsoft.com/en-us/library/microsoft.teamfoundation.workitemtracking.client.query.runlinkquery.aspx" target="_blank"&gt;RunLinkQuery()&lt;/a&gt; method, which returns a WorkItemLinkInfo array. But that’s where my &lt;a href="http://en.wiktionary.org/wiki/Google-fu" target="_blank"&gt;google-fu&lt;/a&gt; ran out of steam – there didn’t seem to be much info about how to proceed once you’ve got this array. So here I’ll show you how I used this array to enumerate the work item hierarchy.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I’ve uploaded the code to my &lt;a href="https://skydrive.live.com/?cid=64a24e0938d6d062&amp;sc=documents&amp;uc=1&amp;id=64A24E0938D6D062%21303#" target="_blank"&gt;skydrive&lt;/a&gt; if you want to download it. (Note: If you want to copy code from the snippets below, just double click in the code area and Cntrl-C).&lt;/p&gt;&lt;br /&gt;&lt;h2&gt;Phase 1 – Setting up the QueryRunner Class&lt;/h2&gt;&lt;br /&gt;&lt;p&gt;In order to work with hierarchical results, you need to execute the query first! Here’s how I did it:&lt;/p&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;class QueryRunner&lt;br /&gt;{&lt;br /&gt;    public WorkItemStore WorkItemStore { get; private set; }&lt;br /&gt;    public string TeamProjectName { get; private set; }&lt;br /&gt;    public string CurrentUserDisplayName { get; private set; }&lt;br /&gt;&lt;br /&gt;    public QueryRunner(string tpcUrl, string teamProjectName)&lt;br /&gt;    {&lt;br /&gt;        var tpc = TfsTeamProjectCollectionFactory.GetTeamProjectCollection(new Uri(tpcUrl));&lt;br /&gt;        WorkItemStore = tpc.GetService&lt;workitemstore&gt;();&lt;br /&gt;        TeamProjectName = teamProjectName;&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;I defined a class called QueryRunner that has a couple of properties:&lt;/p&gt;&lt;br /&gt;&lt;ul&gt;&lt;br /&gt;&lt;li&gt;WorkItemStore – the WorkItemStore service &lt;br /&gt;&lt;li&gt;TeamProjectName – the name of the team project that contains the stored query we want to run &lt;br /&gt;&lt;li&gt;CurrentUserDisplayName – the display name of the current user (more on this later)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;p&gt;You’ll need references to Microsoft.TeamFoundation, Microsoft.TeamFoundation.Client and Microsoft.TeamFoundation.WorkItemTracking.Client, all of which can be found in the .NET tab of the Add References dialogue.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The constructor takes in the Url of the Team Project Collection and the Team Project Name. It then initializes the WorkItemStore.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Two supporting methods you’ll need are the following:&lt;/p&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;private void ResolveCurrentUserDisplayName()&lt;br /&gt;{&lt;br /&gt;    var securityService = WorkItemStore.TeamProjectCollection.GetService&lt;igroupsecurityservice&gt;();&lt;br /&gt;    var accountName = string.Format("{0}\\{1}", Environment.UserDomainName, Environment.UserName);&lt;br /&gt;    var memberInfo = securityService.ReadIdentity(SearchFactor.AccountName, accountName, QueryMembership.None);&lt;br /&gt;    if (memberInfo != null)&lt;br /&gt;    {&lt;br /&gt;        CurrentUserDisplayName = memberInfo.DisplayName;&lt;br /&gt;    }&lt;br /&gt;    else&lt;br /&gt;    {&lt;br /&gt;        CurrentUserDisplayName = Environment.UserName;&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;private IDictionary GetParamsDictionary()&lt;br /&gt;{&lt;br /&gt;    return new Dictionary&lt;string string ,&gt;() &lt;br /&gt;    {&lt;br /&gt;        { "project", TeamProjectName }, &lt;br /&gt;        { "me", CurrentUserDisplayName } &lt;br /&gt;    };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;ResolveCurrentUserDisplayName uses the IGroupSecurityService to resolve the current user’s display name. This is needed if your WIQL contains the “@Me” macro. You can see how it’s used in the GetParamsDictionary method.&lt;/p&gt;&lt;br /&gt;&lt;h2&gt;Phase 2 – Define a Hierarchical Data Structure&lt;/h2&gt;&lt;br /&gt;&lt;p&gt;Now we’re almost ready to execute queries – we just need a data structure to hold the results. Here’s what I ended up defining:&lt;/p&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;class PropertyChangingBase : INotifyPropertyChanged&lt;br /&gt;{&lt;br /&gt;    public event PropertyChangedEventHandler PropertyChanged;&lt;br /&gt;    protected void OnPropertyChanged(string propertyName)&lt;br /&gt;    {&lt;br /&gt;        if (PropertyChanged != null)&lt;br /&gt;        {&lt;br /&gt;            PropertyChanged(this, new PropertyChangedEventArgs(propertyName));&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;class WorkItemNode : PropertyChangingBase&lt;br /&gt;{&lt;br /&gt;    private WorkItem workItem;&lt;br /&gt;    public WorkItem WorkItem&lt;br /&gt;    {&lt;br /&gt;        get { return workItem; }&lt;br /&gt;        set&lt;br /&gt;        {&lt;br /&gt;            workItem = value;&lt;br /&gt;            OnPropertyChanged("WorkItem");&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    private string relationshipToParent;&lt;br /&gt;    public string RelationshipToParent&lt;br /&gt;    {&lt;br /&gt;        get { return relationshipToParent; }&lt;br /&gt;        set&lt;br /&gt;        {&lt;br /&gt;            relationshipToParent = value;&lt;br /&gt;            OnPropertyChanged("RelationshipToParent");&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    private List&lt;workitemnode&gt; children;&lt;br /&gt;    public List&lt;workitemnode&gt; Children&lt;br /&gt;    {&lt;br /&gt;        get { return children; }&lt;br /&gt;        set&lt;br /&gt;        {&lt;br /&gt;            children = value;&lt;br /&gt;            OnPropertyChanged("Children");&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Phase 3 – Run the Query&lt;/h2&gt;&lt;br /&gt;&lt;p&gt;Now we’re ready to run the query.&lt;/p&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;public List&lt;workitemnode&gt; RunQuery(Guid queryGuid)&lt;br /&gt;{&lt;br /&gt;    // get the query&lt;br /&gt;    var queryDef = WorkItemStore.GetQueryDefinition(queryGuid);&lt;br /&gt;    var query = new Query(WorkItemStore, queryDef.QueryText, GetParamsDictionary());&lt;br /&gt;&lt;br /&gt;    // get the link types&lt;br /&gt;    var linkTypes = new List&lt;workitemlinktype&gt;(WorkItemStore.WorkItemLinkTypes);&lt;br /&gt;&lt;br /&gt;    // run the query&lt;br /&gt;    var list = new List&lt;workitemnode&gt;();&lt;br /&gt;    if (queryDef.QueryType == QueryType.List)&lt;br /&gt;    {&lt;br /&gt;        foreach (WorkItem wi in query.RunQuery())&lt;br /&gt;        {&lt;br /&gt;            list.Add(new WorkItemNode() { WorkItem = wi, RelationshipToParent = "" });&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;    else&lt;br /&gt;    {&lt;br /&gt;        var workItemLinks = query.RunLinkQuery().ToList();&lt;br /&gt;        list = WalkLinks(workItemLinks, linkTypes, null);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    return list;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;In this method, we take in the Guid of the query we want to run (how to get that Guid is another discussion – you can see the Guids of stored queries by looking at the TeamProject.QueryHierarchy property). Also, this method is using the WIQL from the stored query, but you could just as well pass in raw WIQL too.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;We construct a Query object passing in the WorkItemStore, the WIQL and the parameter dictionary for “@Project” and “@Me” macros. Next we get a list of all the WorkItemLinkTypes in the WorkItemStore. We’ll use these when we enumerate the work item links.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Finally, we decide on whether or not to run a flat query or a hierarchical query based on the stored query type. If you’re passing in WIQL instead, you’ll have to decide some other way. For flat queries, just construct a list of nodes. For hierarchical queries, get the WorkItemLinkInfo array and walk it using the following (recursive) method:&lt;/p&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;private List&lt;workitemnode&gt; WalkLinks(List&lt;workitemlinkinfo&gt; workItemLinks, List&lt;workitemlinktype&gt; linkTypes, WorkItemNode current)&lt;br /&gt;{&lt;br /&gt;    var currentId = 0;&lt;br /&gt;    if (current != null)&lt;br /&gt;    {&lt;br /&gt;        currentId = current.WorkItem.Id;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    var workItems = (from linkInfo in workItemLinks&lt;br /&gt;                     where linkInfo.SourceId == currentId&lt;br /&gt;                     select new WorkItemNode()&lt;br /&gt;                     {&lt;br /&gt;                         WorkItem = WorkItemStore.GetWorkItem(linkInfo.TargetId),&lt;br /&gt;                         RelationshipToParent = linkInfo.LinkTypeId == 0 ? "Parent" : &lt;br /&gt;                            linkTypes.Single(lt =&gt; lt.ForwardEnd.Id == linkInfo.LinkTypeId).ForwardEnd.Name&lt;br /&gt;                     }).ToList();&lt;br /&gt;    workItems.ForEach(w =&gt; w.Children = WalkLinks(workItemLinks, linkTypes, w));&lt;br /&gt;    return workItems;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;This method walks the array, starting with links that have a source ID of 0 (these are top level work items in the hierarchy). For each of those work items, create a WorkItemNode and then populate the children using the current node as the “current” for the next level of recursion. When we go to the next level, the name of the WorkItemLinkType to the parent can be found using the LinkTypeId property of the WorkItemLinkInfo and finding the corresponding ForwardEnd Id in the list of WorkItemLinkTypes.&lt;/p&gt;&lt;br /&gt;&lt;h2&gt;Epilogue: Displaying the Result in WPF&lt;/h2&gt;&lt;br /&gt;&lt;p&gt;Once you’ve got the tree of WorkItemNodes, displaying them in WPF is really easy. Here’s the XAML for the TreeView:&lt;/p&gt;&lt;pre class="brush: xml; ruler: true;"&gt;&lt;TreeView HorizontalAlignment="Stretch" VerticalAlignment="Stretch" ItemsSource="{Binding}"&gt;&lt;br /&gt;    &lt;TreeView.ItemTemplate&gt;&lt;br /&gt;        &lt;HierarchicalDataTemplate ItemsSource="{Binding Children}"&gt;&lt;br /&gt;            &lt;StackPanel Orientation="Horizontal"&gt;&lt;br /&gt;                &lt;TextBlock Text="{Binding WorkItem.Id, StringFormat=F0}" FontWeight="Bold" /&gt;&lt;br /&gt;                &lt;TextBlock Text="{Binding WorkItem.Title}" Padding="3, 0, 0, 0" /&gt;&lt;br /&gt;                &lt;TextBlock Text="{Binding RelationshipToParent, StringFormat=({0})}" Padding="3, 0, 0, 0" FontStyle="Italic" /&gt;&lt;br /&gt;            &lt;/StackPanel&gt;&lt;br /&gt;        &lt;/HierarchicalDataTemplate&gt;&lt;br /&gt;    &lt;/TreeView.ItemTemplate&gt;&lt;br /&gt;&lt;/TreeView&gt;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;We specify that the ItemTemplate for the TreeView contains hierarchical data. For each node in the tree, display the Id, Title and RelationshipToParent. Then use the “Children” property to display the next level in the hierarchy. In the code-behind for this XAML, we simply set the DataContext to the QueryRunner.RunQuery() results. Here are some screenshots of the results for a one-hop and a tree query respectively.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&lt;a href="http://lh4.ggpht.com/-NON-EatslBg/TpK81AOND6I/AAAAAAAAATs/uCfNtwhpzgE/s1600-h/image2.png"&gt;&lt;img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto; padding-top: 0px" title="image" border="0" alt="image" src="http://lh3.ggpht.com/-k1VQK6W6Dfw/TpK82FdMHhI/AAAAAAAAATw/z3N1sZDsNB4/image_thumb.png?imgmax=800" width="244" height="170"&gt;&lt;/a&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&lt;a href="http://lh3.ggpht.com/-peaYX_PDyUk/TpK827D1pNI/AAAAAAAAAT0/YXwuu9kZObo/s1600-h/image5.png"&gt;&lt;img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto; padding-top: 0px" title="image" border="0" alt="image" src="http://lh5.ggpht.com/-XZfHQDCLAhI/TpK830-TpTI/AAAAAAAAAT4/9x4iAudJGtU/image_thumb1.png?imgmax=800" width="244" height="152"&gt;&lt;/a&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Happy querying!&lt;/p&gt;  </content>
  <ispublished>true</ispublished>
  <categories>
    <category>TFS API</category>
  </categories>
  <comments>
    <comment isAdmin="false" isApproved="true" id="94df5daa-97e1-4b6f-8c84-151c0a17d97a">
      <author>AndrejsM</author>
      <email>noreply@blogger.com</email>
      <website>http://www.blogger.com/profile/16760428047377434422</website>
      <ip></ip>
      <userAgent></userAgent>
      <date>2012-08-16 16:21:56</date>
      <content>Hi, thanks for posting this. I downloaded the code from your skydrive, changed the URL and the project name to what mine actually are. When I run this I get the results window, but it's empty? Any thoughts? Thanks.</content>
    </comment>
    <comment isAdmin="false" isApproved="true" id="4c756bbf-a183-4e9a-90f3-5d4c3fcc94d0">
      <author>Anonymous</author>
      <email>noreply@blogger.com</email>
      <website></website>
      <ip></ip>
      <userAgent></userAgent>
      <date>2013-01-22 03:3:01</date>
      <content>Thanks for the post! Exactly what I wanted. </content>
    </comment>
  </comments>
  <viewCount>6380</viewCount>
</post>