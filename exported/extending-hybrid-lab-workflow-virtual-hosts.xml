<?xml version="1.0" encoding="utf-8"?>
<post>
  <id>109d3c9c-bcae-42b6-b03e-cd47bffecde3</id>
  <title>Extending Hybrid Lab Workflow Virtual Hosts</title>
  <slug>extending-hybrid-lab-workflow-virtual-hosts</slug>
  <shortUrl>http://bit.ly/1rReRcZ</shortUrl>
  <author>Colin Dembovsky</author>
  <pubDate>2012-11-01 15:08:00</pubDate>
  <lastModified>2020-03-28 06:40:20</lastModified>
  <content>&lt;p&gt;In an &lt;a href="http://colinsalmcorner.blogspot.com/2012/10/hybrid-lab-workflow-standard-lab.html" target="_blank"&gt;earlier post&lt;/a&gt; I talked about my &lt;a href="http://hybridlabworkflow.codeplex.com/" target="_blank"&gt;Hybrid Lab Workflow&lt;/a&gt; – this workflow allows you to do a Build-Deploy-Test workflow against a TFS 2012 Standard Environment, and as long as the environment is composed of VMs and you’re able to connect to the VM Host, then you can apply pre-deployment snapshots and take post-deployment snapshots. I also &lt;a href="http://colinsalmcorner.blogspot.com/2012/11/developing-hybrid-lab-workflow.html" target="_blank"&gt;blogged&lt;/a&gt; about the “nastiness” of PsKill and PsExec for getting the Lab into a workable state after snapshots were applied. In this post I’ll talk about how you could use exactly the same workflow for another Virtual Host – say VMWare or something else.&lt;/p&gt; &lt;h2&gt;The Magic – MEF&lt;/h2&gt; &lt;p&gt;When I first thought of this workflow, I immediately thought that I could make the Virtual machine and Virtual Hosts interfaces in the workflow, so that you could hook into any virtualization platform that you want. Lab Management itself if oblivious to the virtualization platform you use (well, in Standard Environments anyway) since it treats the machines as if they are physical (not through the Virtual Host, which is what happens in SCVMM Environments).&lt;/p&gt; &lt;p&gt;So I created an IVirtualHost interface and an IVirtualMachine interface. I then created an enumeration of VirtualHostTypes and a VirtualHostFactory that could instantiate an IVirtualHost concrete class based on the enumeration you fed in. I soon realised that if you wanted to add a Host Type, you’d need to recompile the factory and update the workflow – it would be a bit messy. I ideally wanted something a little more “dynamic”. So I thought of the &lt;a href="http://msdn.microsoft.com/en-us/library/dd460648.aspx" target="_blank"&gt;Managed Extensibility Framework (MEF)&lt;/a&gt; that is now baked into .NET. It’s designed exactly for this sort of problem.&lt;/p&gt; &lt;p&gt;I created a VirtualHostContainer that could dynamically load assemblies and find IVirtualHost implementations. Then I created a static class that uses the container to enumerate the HostTypes available and get you one when you need it.&lt;/p&gt; &lt;h2&gt;VirtualHost Container&lt;/h2&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;namespace HybridLab.Virtual.Interfaces&lt;br /&gt;{&lt;br /&gt;    internal class VirtualHostContainer&lt;br /&gt;    {&lt;br /&gt;        [ImportMany(typeof(IVirtualHost))]&lt;br /&gt;        private IEnumerable&lt;IVirtualHost&gt; VirtualHosts;&lt;br /&gt;&lt;br /&gt;        internal VirtualHostContainer()&lt;br /&gt;        {&lt;br /&gt;            var path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);&lt;br /&gt;            var dlls = new DirectoryInfo(path).GetFileSystemInfos("*.dll");&lt;br /&gt;            var catalog = new AggregateCatalog();&lt;br /&gt;            foreach (var dll in dlls.Where(d =&gt; !(d.Name.StartsWith("System") || d.Name.StartsWith("Microsoft"))))&lt;br /&gt;            {&lt;br /&gt;                try&lt;br /&gt;                {&lt;br /&gt;                    var asm = Assembly.LoadFrom(dll.FullName);&lt;br /&gt;                    var assemblyCatalog = new AssemblyCatalog(asm);&lt;br /&gt;                    if (assemblyCatalog.Parts.Count() &gt; 0)&lt;br /&gt;                    {&lt;br /&gt;                        catalog.Catalogs.Add(assemblyCatalog);&lt;br /&gt;                    }&lt;br /&gt;                }&lt;br /&gt;                catch (Exception)&lt;br /&gt;                {&lt;br /&gt;                }&lt;br /&gt;            }&lt;br /&gt;            new CompositionContainer(catalog).SatisfyImportsOnce(this);&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        internal List&lt;string&gt; GetHostTypes()&lt;br /&gt;        {&lt;br /&gt;            return (from h in VirtualHosts&lt;br /&gt;                    select h.HostType).ToList();&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        internal IVirtualHost GetHost(string hostType, string hostName, string domain = "", string userName = "", string password = "")&lt;br /&gt;        {&lt;br /&gt;            var host = VirtualHosts.Single(h =&gt; h.HostType == hostType);&lt;br /&gt;            host.Connect(hostName, domain, userName, password);&lt;br /&gt;            return host;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;Above is the container code. The VirtualHosts property is attributed with an [ImportMany] attribute. The MEF framework will inject any classes that are attributed with the matching [Export] attribute into this property. This is done on line 28 in the call to SatisfyImportsOnce().&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once that property is populated, the GetHostTypes() and GetHost() methods are trivial. What’s a little trickier is dynamically loading the assemblies that may (or may not) contain IVirtualHost implementations. For that I just get the current assembly’s location and then try to load each dll (that doesn’t start with Microsoft or System). I create a new AssemblyCatalog from the assembly, and if there are any MEF exports (parts) in the assembly, I add the catalog to an AggregateCatalog. Once I’ve got all the AssemblyCatalogs into the AggregateCatalog, I create a CompositionContainer and tell it to make any hook ups using the SatisfyImportsOnce call on the VirtualHostContainer itself.&lt;/p&gt;&lt;br /&gt;&lt;h2&gt;Virtual Host Catalog&lt;/h2&gt;&lt;br /&gt;&lt;p&gt;I’ve wrapped this class into a static class that you can call to get VirtualHosts. Here it is:&lt;/p&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;namespace HybridLab.Virtual.Interfaces&lt;br /&gt;{&lt;br /&gt;    public sealed class VirtualHostCatalog&lt;br /&gt;    {&lt;br /&gt;        public static List&lt;string&gt; GetHostTypes()&lt;br /&gt;        {&lt;br /&gt;            return new VirtualHostContainer().GetHostTypes();&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        public static IVirtualHost GetHost(string hostType, string hostName, string domain = "", string userName = "", string password = "")&lt;br /&gt;        {&lt;br /&gt;            return new VirtualHostContainer().GetHost(hostType, hostName, domain, userName, password);&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Implementing IVirtualHost and IVirtualMachine&lt;/h2&gt;&lt;br /&gt;&lt;p&gt;These interfaces are really simple (like all good interfaces). When I was implementing them for HyperV (on Windows 8) I realized that you can have a simple interface and a complicated implementation. I suppose that’s the power of interfaces – the interface consumer doesn’t have to care.&lt;/p&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;namespace HybridLab.Virtual.Interfaces&lt;br /&gt;{&lt;br /&gt;    public interface IVirtualHost&lt;br /&gt;    {&lt;br /&gt;        string HostName { get; }&lt;br /&gt;        string Domain { get; }&lt;br /&gt;        string UserName { get; }&lt;br /&gt;        string Password { get; }&lt;br /&gt;        string HostType { get; }&lt;br /&gt;        &lt;br /&gt;        void Connect(string hostName, string domain, string userName, string password);&lt;br /&gt;&lt;br /&gt;        List&lt;IVirtualMachine&gt; GetVMs();&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;The IVirtualHost has a couple of properties – the host type is used dynamically to discover host types. The rest are connection properties – the host name and admin credentials to the host machine. The Connect() method gets called in the VirtualHostContainer, so you don’t actually ever need to call it yourself. The final method is the method to get the list of VMs on the host.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I’ve also supplied an abstract HostBase class to get you started:&lt;/p&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;namespace HybridLab.Virtual.Interfaces&lt;br /&gt;{&lt;br /&gt;    public abstract class HostBase : IVirtualHost&lt;br /&gt;    {&lt;br /&gt;        public string HostName { get; protected set; }&lt;br /&gt;        public string Domain   { get; protected set; }&lt;br /&gt;        public string UserName { get; protected set; }&lt;br /&gt;        public string Password { get; protected set; }&lt;br /&gt;&lt;br /&gt;        public virtual string HostType { get; protected set; }&lt;br /&gt;&lt;br /&gt;        public virtual void Connect(string hostName, string domain, string userName, string password)&lt;br /&gt;        {&lt;br /&gt;            HostName = hostName;&lt;br /&gt;            Domain = domain;&lt;br /&gt;            UserName = userName;&lt;br /&gt;            Password = password;&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        public virtual List&lt;IVirtualMachine&gt; GetVMs()&lt;br /&gt;        {&lt;br /&gt;            throw new NotImplementedException();&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;The IVirtualMachine interface is also fairly simple:&lt;/p&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;namespace HybridLab.Virtual.Interfaces&lt;br /&gt;{&lt;br /&gt;    public interface IVirtualMachine&lt;br /&gt;    {&lt;br /&gt;        void ApplySnapshot(string snapshotName);&lt;br /&gt;&lt;br /&gt;        void CreateSnapshot(string snapshotPrefix);&lt;br /&gt;&lt;br /&gt;        IVirtualHost Host { get; }&lt;br /&gt;&lt;br /&gt;        string Name { get; }&lt;br /&gt;&lt;br /&gt;        string DnsName { get; }&lt;br /&gt;&lt;br /&gt;        List&lt;string&gt; Snapshots { get; }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;There’s a reference to the VMs IVirtualHost, a name, a property that returns all the snapshots and the DnsName of the guest OS. Then there are ApplySnapshot() and CreateSnapshot() for doing those operations.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once you’ve implemented an IVirtualHost and IVirtualMachine, simply add the MEF Export attribute onto your IVirtualHost implementation and drop the assembly into source control along with the interface and other assemblies for the Hybrid Lab Workflow. You won’t need to change the workflow at all.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Here’s an example TestHost that I implemented for testing the VirtualHostCatalog class:&lt;/p&gt;&lt;pre class="brush: csharp; ruler: true;"&gt;namespace HybridLab.Virtual.TestHost&lt;br /&gt;{&lt;br /&gt;    [Export(typeof(IVirtualHost))]&lt;br /&gt;    public class TestHost : HostBase&lt;br /&gt;    {&lt;br /&gt;        public override string HostType&lt;br /&gt;        {&lt;br /&gt;            get&lt;br /&gt;            {&lt;br /&gt;                return "Test";&lt;br /&gt;            }&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;Note the [Export] attribute decorating the class. Of course you’ll need some more code for a real host implementation!&lt;/p&gt;&lt;br /&gt;&lt;p&gt;That’s all there is to it. If you’re going to be implementing a host and need some help, let me know! Also, I can add it to the &lt;a href="http://hybridlabworkflow.codeplex.com/" target="_blank"&gt;Hybrid Lab Workflow project on Codeplex&lt;/a&gt;.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Happy implementing!&lt;/p&gt;  </content>
  <ispublished>true</ispublished>
  <categories>
    <category>teambuild</category>
    <category>Lab Management</category>
  </categories>
  <comments></comments>
  <viewCount>2320</viewCount>
</post>